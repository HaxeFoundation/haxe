/*
 * Copyright (C)2005-2019 Haxe Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

package hl.uv;

// This file is automatically generated by a tool in Hashlink repo.
// see <hashlink_repo>/other/uvgenerator

// Contents of UV.hx.header

typedef UInt = Int;
typedef U64 = I64;

typedef UvRunMode = Loop.LoopRunMode;

/**
	Automatically generated bindings for libuv.
	Avoid using this module directly.
	BACKWARD COMPATIBILITY OF THIS MODULE IS NOT MAINTAINED.
**/
@:hlNative("uv")
extern class UV {
	extern static public inline function resolve(result:Int):Int {
		if(result < 0)
			throw new UVException(translate_uv_error(result));
		return result;
	}

	static public function translate_uv_error(uvErrno:Int):UVError;
	static public function translate_to_uv_error(errno:Int):Int;
	static public function handle_data_of_pointer(ptr:Pointer):HandleData;
	static public function handle_data_to_pointer(data:HandleData):Pointer;
	static public function handle_set_data_with_gc(handle:Handle, data:HandleData):Void;
	static public function alloc_loop():Loop;
	static public function alloc_async():Async;
	static public function alloc_timer():Timer;

// Auto generated

	static public function async_init_with_cb(loop:Loop, async:Async):Int;
	static public function async_send(async:Async):Int;
	// static public function check_init(loop:Loop, check:Check):Int return cast null;
	// static public function check_start_with_cb(check:Check):Int return cast null;
	// static public function check_stop(check:Check):Int return cast null;
	// static public function getaddrinfo_with_cb(loop:Loop, req:Getaddrinfo, node:Bytes, service:Bytes, hints:Ref<Addrinfo>):Int return cast null;
	// static public function freeaddrinfo(ai:Ref<Addrinfo>):Void {}
	// static public function getnameinfo_with_cb(loop:Loop, req:Getnameinfo, addr:Ref<Sockaddr>, flags:Int):Int return cast null;
	static public function strerror(err:Int):Bytes;
	// static public function strerror_r(err:Int, buf:Bytes, buflen:U64):Bytes return cast null;
	static public function err_name(err:Int):Bytes;
	// static public function err_name_r(err:Int, buf:Bytes, buflen:U64):Bytes return cast null;
	// static public function translate_sys_error(sys_errno:Int):Int return cast null;
	// static public function fs_req_cleanup(req:Fs):Void {}
	// static public function fs_close_with_cb(loop:Loop, req:Fs, file:UvFile, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_open_with_cb(loop:Loop, req:Fs, path:Bytes, flags:Int, mode:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_read_with_cb(loop:Loop, req:Fs, file:UvFile, bufs:Ref<Buf>, nbufs:UInt, offset:I64, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_unlink_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_write_with_cb(loop:Loop, req:Fs, file:UvFile, bufs:Ref<Buf>, nbufs:UInt, offset:I64, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_mkdir_with_cb(loop:Loop, req:Fs, path:Bytes, mode:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_mkdtemp_with_cb(loop:Loop, req:Fs, tpl:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_mkstemp_with_cb(loop:Loop, req:Fs, tpl:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_rmdir_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_opendir_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_closedir_with_cb(loop:Loop, req:Fs, dir:Dir, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_readdir_with_cb(loop:Loop, req:Fs, dir:Dir, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_scandir_with_cb(loop:Loop, req:Fs, path:Bytes, flags:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_scandir_next(req:Fs, ent:Dirent):Int return cast null;
	// static public function fs_stat_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_fstat_with_cb(loop:Loop, req:Fs, file:UvFile, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_lstat_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_statfs_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_rename_with_cb(loop:Loop, req:Fs, path:Bytes, new_path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_fsync_with_cb(loop:Loop, req:Fs, file:UvFile, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_fdatasync_with_cb(loop:Loop, req:Fs, file:UvFile, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_ftruncate_with_cb(loop:Loop, req:Fs, file:UvFile, offset:I64, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_copyfile_with_cb(loop:Loop, req:Fs, path:Bytes, new_path:Bytes, flags:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_sendfile_with_cb(loop:Loop, req:Fs, out_fd:UvFile, in_fd:UvFile, in_offset:I64, length:U64, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_access_with_cb(loop:Loop, req:Fs, path:Bytes, mode:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_chmod_with_cb(loop:Loop, req:Fs, path:Bytes, mode:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_fchmod_with_cb(loop:Loop, req:Fs, file:UvFile, mode:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_utime_with_cb(loop:Loop, req:Fs, path:Bytes, atime:Float, mtime:Float, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_futime_with_cb(loop:Loop, req:Fs, file:UvFile, atime:Float, mtime:Float, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_lutime_with_cb(loop:Loop, req:Fs, path:Bytes, atime:Float, mtime:Float, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_link_with_cb(loop:Loop, req:Fs, path:Bytes, new_path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_symlink_with_cb(loop:Loop, req:Fs, path:Bytes, new_path:Bytes, flags:Int, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_readlink_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_realpath_with_cb(loop:Loop, req:Fs, path:Bytes, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_chown_with_cb(loop:Loop, req:Fs, path:Bytes, uid:Uid, gid:Gid, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_fchown_with_cb(loop:Loop, req:Fs, file:UvFile, uid:Uid, gid:Gid, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_lchown_with_cb(loop:Loop, req:Fs, path:Bytes, uid:Uid, gid:Gid, use_uv_fs_cb:Bool):Int return cast null;
	// static public function fs_get_type(req:Fs):UvFsType return cast null;
	// static public function fs_get_result(req:Fs):I64 return cast null;
	// static public function fs_get_system_error(req:Fs):Int return cast null;
	// static public function fs_get_ptr(req:Fs):Pointer return cast null;
	// static public function fs_get_path(req:Fs):Bytes return cast null;
	// static public function fs_get_statbuf(req:Fs):Stat return cast null;
	// static public function get_osfhandle(fd:Int):OsFd return cast null;
	// static public function open_osfhandle(os_fd:OsFd):Int return cast null;
	// static public function fs_event_init(loop:Loop, handle:FsEvent):Int return cast null;
	// static public function fs_event_start_with_cb(handle:FsEvent, path:Bytes, flags:UInt):Int return cast null;
	// static public function fs_event_stop(handle:FsEvent):Int return cast null;
	// static public function fs_event_getpath(handle:FsEvent, buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function fs_poll_init(loop:Loop, handle:FsPoll):Int return cast null;
	// static public function fs_poll_start_with_cb(handle:FsPoll, path:Bytes, interval:UInt):Int return cast null;
	// static public function fs_poll_stop(handle:FsPoll):Int return cast null;
	// static public function fs_poll_getpath(handle:FsPoll, buffer:Bytes, size:Ref<U64>):Int return cast null;
	static public function is_active(handle:Handle):Int;
	static public function is_closing(handle:Handle):Int;
	static public function close_with_cb(handle:Handle):Void;
	static public function ref(handle:Handle):Void;
	static public function unref(handle:Handle):Void;
	static public function has_ref(handle:Handle):Int;
	// static public function handle_size(type:UvHandleType):U64 return cast null;
	// static public function send_buffer_size(handle:Handle, value:Ref<Int>):Int return cast null;
	// static public function recv_buffer_size(handle:Handle, value:Ref<Int>):Int return cast null;
	// static public function fileno(handle:Handle, fd:OsFd):Int return cast null;
	// static public function handle_get_loop(handle:Handle):Loop return cast null;
	static public function handle_get_data(handle:Handle):Pointer;
	static public function handle_set_data(handle:Handle, data:Pointer):Pointer;
	// static public function handle_get_type(handle:Handle):UvHandleType return cast null;
	// static public function handle_type_name(type:UvHandleType):Bytes return cast null;
	// static public function idle_init(loop:Loop, idle:Idle):Int return cast null;
	// static public function idle_start_with_cb(idle:Idle):Int return cast null;
	// static public function idle_stop(idle:Idle):Int return cast null;
	static public function loop_init(loop:Loop):Int;
	static public function loop_close(loop:Loop):Int;
	static public function default_loop():Loop;
	static public function run(loop:Loop, mode:UvRunMode):Int;
	static public function loop_alive(loop:Loop):Int;
	static public function stop(loop:Loop):Void;
	// static public function loop_size():U64 return cast null;
	// static public function backend_fd(loop:Loop):Int return cast null;
	// static public function backend_timeout(loop:Loop):Int return cast null;
	// static public function now(loop:Loop):U64 return cast null;
	// static public function update_time(loop:Loop):Void {}
	// static public function walk_with_cb(loop:Loop, arg:Pointer):Void {}
	// static public function loop_fork(loop:Loop):Int return cast null;
	// static public function loop_get_data(loop:Loop):Pointer return cast null;
	// static public function loop_set_data(loop:Loop, data:Pointer):Pointer return cast null;
	// static public function metrics_idle_time(loop:Loop):U64 return cast null;
	// static public function guess_handle(file:UvFile):UvHandleType return cast null;
	// static public function replace_allocator(malloc_func:UvMallocFunc, realloc_func:UvReallocFunc, calloc_func:UvCallocFunc, free_func:UvFreeFunc):Int return cast null;
	// static public function library_shutdown():Void {}
	// static public function buf_init(base:Bytes, len:UInt):Buf return cast null;
	// static public function setup_args(argc:Int, argv:Ref<Bytes>):Ref<Bytes> return cast null;
	// static public function get_process_title(buffer:Bytes, size:U64):Int return cast null;
	// static public function set_process_title(title:Bytes):Int return cast null;
	// static public function resident_set_memory(rss:Ref<U64>):Int return cast null;
	// static public function uptime(uptime:Ref<Float>):Int return cast null;
	// static public function getrusage(rusage:Rusage):Int return cast null;
	// static public function os_getpid():Pid return cast null;
	// static public function os_getppid():Pid return cast null;
	// static public function cpu_info(cpu_infos:Ref<CpuInfo>, count:Ref<Int>):Int return cast null;
	// static public function free_cpu_info(cpu_infos:CpuInfo, count:Int):Void {}
	// static public function interface_addresses(addresses:Ref<InterfaceAddress>, count:Ref<Int>):Int return cast null;
	// static public function free_interface_addresses(addresses:InterfaceAddress, count:Int):Void {}
	// static public function loadavg(avg:Ref<Float>):Void {}
	// static public function ip4_addr(ip:Bytes, port:Int, addr:Ref<SockaddrIn>):Int return cast null;
	// static public function ip6_addr(ip:Bytes, port:Int, addr:Ref<SockaddrIn6>):Int return cast null;
	// static public function ip4_name(src:Ref<SockaddrIn>, dst:Bytes, size:U64):Int return cast null;
	// static public function ip6_name(src:Ref<SockaddrIn6>, dst:Bytes, size:U64):Int return cast null;
	// static public function inet_ntop(af:Int, src:Pointer, dst:Bytes, size:U64):Int return cast null;
	// static public function inet_pton(af:Int, src:Bytes, dst:Pointer):Int return cast null;
	// static public function if_indextoname(ifindex:UInt, buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function if_indextoiid(ifindex:UInt, buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function exepath(buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function cwd(buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function chdir(dir:Bytes):Int return cast null;
	// static public function os_homedir(buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function os_tmpdir(buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function os_get_passwd(pwd:Passwd):Int return cast null;
	// static public function os_free_passwd(pwd:Passwd):Void {}
	// static public function get_free_memory():U64 return cast null;
	// static public function get_total_memory():U64 return cast null;
	// static public function get_constrained_memory():U64 return cast null;
	// static public function hrtime():U64 return cast null;
	// static public function print_all_handles(loop:Loop, stream:Ref<FILE>):Void {}
	// static public function print_active_handles(loop:Loop, stream:Ref<FILE>):Void {}
	// static public function os_environ(envitems:Ref<EnvItem>, count:Ref<Int>):Int return cast null;
	// static public function os_free_environ(envitems:EnvItem, count:Int):Void {}
	// static public function os_getenv(name:Bytes, buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function os_setenv(name:Bytes, value:Bytes):Int return cast null;
	// static public function os_unsetenv(name:Bytes):Int return cast null;
	// static public function os_gethostname(buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function os_getpriority(pid:Pid, priority:Ref<Int>):Int return cast null;
	// static public function os_setpriority(pid:Pid, priority:Int):Int return cast null;
	// static public function os_uname(buffer:Utsname):Int return cast null;
	// static public function gettimeofday(tv:Timeval64):Int return cast null;
	// static public function random_with_cb(loop:Loop, req:Random, buf:Pointer, buflen:U64, flags:UInt):Int return cast null;
	// static public function sleep(msec:UInt):Void {}
	// static public function pipe_init(loop:Loop, handle:Pipe, ipc:Int):Int return cast null;
	// static public function pipe_open(handle:Pipe, file:UvFile):Int return cast null;
	// static public function pipe_bind(handle:Pipe, name:Bytes):Int return cast null;
	// static public function pipe_connect_with_cb(req:Connect, handle:Pipe, name:Bytes):Void {}
	// static public function pipe_getsockname(handle:Pipe, buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function pipe_getpeername(handle:Pipe, buffer:Bytes, size:Ref<U64>):Int return cast null;
	// static public function pipe_pending_instances(handle:Pipe, count:Int):Void {}
	// static public function pipe_pending_count(handle:Pipe):Int return cast null;
	// static public function pipe_pending_type(handle:Pipe):UvHandleType return cast null;
	// static public function pipe_chmod(handle:Pipe, flags:Int):Int return cast null;
	// static public function pipe(fds:Ref<UvFile>, read_flags:Int, write_flags:Int):Int return cast null;
	// static public function prepare_init(loop:Loop, prepare:Prepare):Int return cast null;
	// static public function prepare_start_with_cb(prepare:Prepare):Int return cast null;
	// static public function prepare_stop(prepare:Prepare):Int return cast null;
	// static public function disable_stdio_inheritance():Void {}
	// static public function spawn(loop:Loop, handle:Process, options:ProcessOptions):Int return cast null;
	// static public function process_kill(handle:Process, signum:Int):Int return cast null;
	// static public function kill(pid:Int, signum:Int):Int return cast null;
	// static public function process_get_pid(handle:Process):Pid return cast null;
	// static public function cancel(req:Req):Int return cast null;
	// static public function req_size(type:UvReqType):U64 return cast null;
	// static public function req_get_data(req:Req):Pointer return cast null;
	// static public function req_set_data(req:Req, data:Pointer):Pointer return cast null;
	// static public function req_get_type(req:Req):UvReqType return cast null;
	// static public function req_type_name(type:UvReqType):Bytes return cast null;
	// static public function signal_init(loop:Loop, signal:Signal):Int return cast null;
	// static public function signal_start_with_cb(signal:Signal, signum:Int):Int return cast null;
	// static public function signal_start_oneshot_with_cb(signal:Signal, signum:Int):Int return cast null;
	// static public function signal_stop(signal:Signal):Int return cast null;
	// static public function shutdown_with_cb(req:Shutdown, handle:Stream):Int return cast null;
	// static public function listen_with_cb(stream:Stream, backlog:Int):Int return cast null;
	// static public function accept(server:Stream, client:Stream):Int return cast null;
	// static public function read_start_with_cb(stream:Stream):Int return cast null;
	// static public function read_stop(:Stream):Int return cast null;
	// static public function write_with_cb(req:Write, handle:Stream, bufs:Ref<Buf>, nbufs:UInt):Int return cast null;
	// static public function write2_with_cb(req:Write, handle:Stream, bufs:Ref<Buf>, nbufs:UInt, send_handle:Stream):Int return cast null;
	// static public function try_write(handle:Stream, bufs:Ref<Buf>, nbufs:UInt):Int return cast null;
	// static public function try_write2(handle:Stream, bufs:Ref<Buf>, nbufs:UInt, send_handle:Stream):Int return cast null;
	// static public function is_readable(handle:Stream):Int return cast null;
	// static public function is_writable(handle:Stream):Int return cast null;
	// static public function stream_set_blocking(handle:Stream, blocking:Int):Int return cast null;
	// static public function stream_get_write_queue_size(stream:Stream):U64 return cast null;
	// static public function tcp_init(loop:Loop, handle:Tcp):Int return cast null;
	// static public function tcp_init_ex(loop:Loop, handle:Tcp, flags:UInt):Int return cast null;
	// static public function tcp_open(handle:Tcp, sock:OsSock):Int return cast null;
	// static public function tcp_nodelay(handle:Tcp, enable:Int):Int return cast null;
	// static public function tcp_keepalive(handle:Tcp, enable:Int, delay:UInt):Int return cast null;
	// static public function tcp_simultaneous_accepts(handle:Tcp, enable:Int):Int return cast null;
	// static public function tcp_bind(handle:Tcp, addr:Ref<Sockaddr>, flags:UInt):Int return cast null;
	// static public function tcp_getsockname(handle:Tcp, name:Ref<Sockaddr>, namelen:Ref<Int>):Int return cast null;
	// static public function tcp_getpeername(handle:Tcp, name:Ref<Sockaddr>, namelen:Ref<Int>):Int return cast null;
	// static public function tcp_connect_with_cb(req:Connect, handle:Tcp, addr:Ref<Sockaddr>):Int return cast null;
	// static public function tcp_close_reset_with_cb(handle:Tcp):Int return cast null;
	// static public function socketpair(type:Int, protocol:Int, socket_vector:Ref<OsSock>, flags0:Int, flags1:Int):Int return cast null;
	static public function timer_init(loop:Loop, handle:Timer):Int;
	static public function timer_start_with_cb(handle:Timer, timeout:U64, repeat:U64):Int;
	static public function timer_stop(handle:Timer):Int;
	static public function timer_again(handle:Timer):Int;
	static public function timer_set_repeat(handle:Timer, repeat:U64):Void;
	static public function timer_get_repeat(handle:Timer):U64;
	static public function timer_get_due_in(handle:Timer):U64;
	// static public function tty_init(loop:Loop, handle:Tty, fd:UvFile, unused:Int):Int return cast null;
	// static public function tty_set_mode(handle:Tty, mode:TtyMode):Int return cast null;
	// static public function tty_reset_mode():Int return cast null;
	// static public function tty_get_winsize(handle:Tty, width:Ref<Int>, height:Ref<Int>):Int return cast null;
	// static public function tty_set_vterm_state(state:TtyVtermstate):Void {}
	// static public function tty_get_vterm_state(state:TtyVtermstate):Int return cast null;
	// static public function udp_init(loop:Loop, handle:Udp):Int return cast null;
	// static public function udp_init_ex(loop:Loop, handle:Udp, flags:UInt):Int return cast null;
	// static public function udp_open(handle:Udp, sock:OsSock):Int return cast null;
	// static public function udp_bind(handle:Udp, addr:Ref<Sockaddr>, flags:UInt):Int return cast null;
	// static public function udp_connect(handle:Udp, addr:Ref<Sockaddr>):Int return cast null;
	// static public function udp_getpeername(handle:Udp, name:Ref<Sockaddr>, namelen:Ref<Int>):Int return cast null;
	// static public function udp_getsockname(handle:Udp, name:Ref<Sockaddr>, namelen:Ref<Int>):Int return cast null;
	// static public function udp_set_membership(handle:Udp, multicast_addr:Bytes, interface_addr:Bytes, membership:UvMembership):Int return cast null;
	// static public function udp_set_source_membership(handle:Udp, multicast_addr:Bytes, interface_addr:Bytes, source_addr:Bytes, membership:UvMembership):Int return cast null;
	// static public function udp_set_multicast_loop(handle:Udp, on:Int):Int return cast null;
	// static public function udp_set_multicast_ttl(handle:Udp, ttl:Int):Int return cast null;
	// static public function udp_set_multicast_interface(handle:Udp, interface_addr:Bytes):Int return cast null;
	// static public function udp_set_broadcast(handle:Udp, on:Int):Int return cast null;
	// static public function udp_set_ttl(handle:Udp, ttl:Int):Int return cast null;
	// static public function udp_send_with_cb(req:UdpSend, handle:Udp, bufs:Ref<Buf>, nbufs:UInt, addr:Ref<Sockaddr>):Int return cast null;
	// static public function udp_try_send(handle:Udp, bufs:Ref<Buf>, nbufs:UInt, addr:Ref<Sockaddr>):Int return cast null;
	// static public function udp_recv_start_with_cb(handle:Udp):Int return cast null;
	// static public function udp_using_recvmmsg(handle:Udp):Int return cast null;
	// static public function udp_recv_stop(handle:Udp):Int return cast null;
	// static public function udp_get_send_queue_size(handle:Udp):U64 return cast null;
	// static public function udp_get_send_queue_count(handle:Udp):U64 return cast null;
	// static public function version():UInt return cast null;
	// static public function version_string():Bytes return cast null;
}
