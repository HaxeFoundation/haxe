/*
 * Copyright (C)2005-2019 Haxe Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

package hl.uv;

import hl.uv.Request;
import hl.uv.Handle;
import hl.uv.SockAddr;
import hl.uv.Dns;
import hl.uv.Loop;
import hl.uv.File;
import hl.uv.Stream;
import hl.uv.Tty;
import hl.uv.Udp;
import hl.uv.Misc.RandomRequest;
import hl.uv.Dir;

// This file is automatically generated by a tool in Hashlink repo.
// see <hashlink_repo>/other/uvgenerator

// Contents of UV.hx.header

abstract RawAddrInfo(Abstract<"struct_addrinfo">) {}
abstract RawDirent(Abstract<"uv_dirent">) {}
abstract RawStat(Abstract<"uv_stat">) {}
abstract RawStatFs(Abstract<"uv_statfs">) {}
abstract RawRUsage(Abstract<"uv_rusage">) {}
abstract RawCpuInfo(Abstract<"uv_cpuinfo">) {}
abstract RawInterfaceAddress(Abstract<"uv_interface_address">) {}
abstract RawSockAddrIn(Abstract<"struct_sockaddr_in">) {}
abstract RawSockAddrIn6(Abstract<"struct_sockaddr_in6">) {}
abstract RawPasswd(Abstract<"uv_passwd">) {}
abstract RawUtsName(Abstract<"uv_utsname">) {}
abstract RawTimeVal(Abstract<"uv_timeval">) {}
abstract RawTimeVal64(Abstract<"uv_timeval64">) {}
abstract RawProcessOptions(Abstract<"uv_process_options">) {}

//TODO: implement these
private typedef UInt = Int;
private typedef U64 = I64;

/**
	Automatically generated bindings for libuv.
	Avoid using this module directly.
	BACKWARD COMPATIBILITY OF THIS MODULE IS NOT MAINTAINED.
**/
@:hlNative("uv")
extern class UV {
	extern static public inline function resolve(result:Int):Int {
		if(result < 0)
			throw new UVException(translate_uv_error(result));
		return result;
	}

	extern static public inline function throwErr(result:Int):Int {
		throw new UVException(translate_uv_error(result));
	}

	extern static public inline function toUTF8(s:String):Bytes {
		return @:privateAccess s.toUtf8();
	}

	extern static public inline function fromUTF8(b:Bytes):String {
		return @:privateAccess String.fromUTF8(b);
	}

	static public function free(ptr:Pointer):Void;
	static public function bytes_to_pointer(bytes:Bytes):Pointer;
	static public function translate_uv_error(uvErrno:Int):UVError;
	static public function translate_to_uv_error(errno:Int):Int;
	static public function pointer_to_handle_data(ptr:Pointer):HandleData;
	static public function handle_data_to_pointer(data:HandleData):Pointer;
	static public function handle_to_pointer(data:Handle):Pointer;
	static public function handle_set_data_with_gc(handle:Handle, data:HandleData):Void;
	static public function pointer_to_req_data(ptr:Pointer):RequestData;
	static public function req_data_to_pointer(data:RequestData):Pointer;
	static public function req_set_data_with_gc(req:Request, data:RequestData):Void;
	static public function req_to_pointer(req:Request):Pointer;
	static public function alloc_loop():Loop;
	static public function alloc_async():Async;
	static public function alloc_timer():Timer;
	static public function alloc_check():Check;
	static public function alloc_getaddrinfo():AddrInfoRequest;
	static public function alloc_getnameinfo():NameInfoRequest;
	static public function alloc_addrinfo(flags:Int, family:AddressFamily, socktype:SocketType, protocol:Int):RawAddrInfo;
	static public function addrinfo_ai_family(ai:RawAddrInfo):AddressFamily;
	static public function addrinfo_ai_socktype(ai:RawAddrInfo):SocketType;
	static public function addrinfo_ai_protocol(ai:RawAddrInfo):Int;
	static public function addrinfo_ai_addr(ai:RawAddrInfo):SockAddr;
	static public function addrinfo_ai_canonname(ai:RawAddrInfo):Bytes;
	static public function addrinfo_ai_next(ai:RawAddrInfo):Null<RawAddrInfo>;
	static public function nameinfo_flags_to_native(ai:NameInfoFlags):Int;
	static public function alloc_fs():FsRequest;
	static public function pointer_to_dir(req:Pointer):Dir;
	static public function dir_init(dir:Dir, num_entries:Int):Void;
	static public function dir_nentries(dir:Dir):Int;
	static public function dir_dirent(dir:Dir, index:Int):RawDirent;
	static public function dirent_to_pointer(dirent:RawDirent):Pointer;
	static public function dirent_name(dirent:RawDirent):Bytes;
	static public function dirent_type(dirent:RawDirent):DirEntryType;

// Auto generated

	static public function async_init_with_cb(loop:Loop, async:Async):Int;
	static public function async_send(async:Async):Int;
	static public function check_init(loop:Loop, check:Check):Int;
	static public function check_start_with_cb(check:Check):Int;
	static public function check_stop(check:Check):Int;
	static public function getaddrinfo_with_cb(loop:Loop, req:AddrInfoRequest, node:Bytes, service:Bytes, hints:RawAddrInfo):Int;
	static public function freeaddrinfo(ai:RawAddrInfo):Void;
	static public function getnameinfo_with_cb(loop:Loop, req:NameInfoRequest, addr:SockAddr, flags:Int):Int;
	static public function strerror(err:Int):Bytes;
	static public function strerror_r(err:Int, buf:Bytes, buflen:U64):Bytes;
	static public function err_name(err:Int):Bytes;
	static public function err_name_r(err:Int, buf:Bytes, buflen:U64):Bytes;
	static public function translate_sys_error(sys_errno:Int):Int;
	static public function fs_req_cleanup(req:FsRequest):Void;
	static public function fs_close_with_cb(loop:Loop, req:FsRequest, file:File, use_uv_fs_cb:Bool):Int;
	static public function fs_open_with_cb(loop:Loop, req:FsRequest, path:Bytes, flags:Int, mode:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_read_with_cb(loop:Loop, req:FsRequest, file:File, bufs:Ref<Buffer>, nbufs:UInt, offset:I64, use_uv_fs_cb:Bool):Int;
	static public function fs_unlink_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_write_with_cb(loop:Loop, req:FsRequest, file:File, bufs:Ref<Buffer>, nbufs:UInt, offset:I64, use_uv_fs_cb:Bool):Int;
	static public function fs_mkdir_with_cb(loop:Loop, req:FsRequest, path:Bytes, mode:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_mkdtemp_with_cb(loop:Loop, req:FsRequest, tpl:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_mkstemp_with_cb(loop:Loop, req:FsRequest, tpl:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_rmdir_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_opendir_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_closedir_with_cb(loop:Loop, req:FsRequest, dir:Dir, use_uv_fs_cb:Bool):Int;
	static public function fs_readdir_with_cb(loop:Loop, req:FsRequest, dir:Dir, use_uv_fs_cb:Bool):Int;
	static public function fs_scandir_with_cb(loop:Loop, req:FsRequest, path:Bytes, flags:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_scandir_next(req:FsRequest, ent:RawDirent):Int;
	static public function fs_stat_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_fstat_with_cb(loop:Loop, req:FsRequest, file:File, use_uv_fs_cb:Bool):Int;
	static public function fs_lstat_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_statfs_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_rename_with_cb(loop:Loop, req:FsRequest, path:Bytes, new_path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_fsync_with_cb(loop:Loop, req:FsRequest, file:File, use_uv_fs_cb:Bool):Int;
	static public function fs_fdatasync_with_cb(loop:Loop, req:FsRequest, file:File, use_uv_fs_cb:Bool):Int;
	static public function fs_ftruncate_with_cb(loop:Loop, req:FsRequest, file:File, offset:I64, use_uv_fs_cb:Bool):Int;
	static public function fs_copyfile_with_cb(loop:Loop, req:FsRequest, path:Bytes, new_path:Bytes, flags:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_sendfile_with_cb(loop:Loop, req:FsRequest, out_fd:File, in_fd:File, in_offset:I64, length:U64, use_uv_fs_cb:Bool):Int;
	static public function fs_access_with_cb(loop:Loop, req:FsRequest, path:Bytes, mode:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_chmod_with_cb(loop:Loop, req:FsRequest, path:Bytes, mode:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_fchmod_with_cb(loop:Loop, req:FsRequest, file:File, mode:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_utime_with_cb(loop:Loop, req:FsRequest, path:Bytes, atime:Float, mtime:Float, use_uv_fs_cb:Bool):Int;
	static public function fs_futime_with_cb(loop:Loop, req:FsRequest, file:File, atime:Float, mtime:Float, use_uv_fs_cb:Bool):Int;
	static public function fs_lutime_with_cb(loop:Loop, req:FsRequest, path:Bytes, atime:Float, mtime:Float, use_uv_fs_cb:Bool):Int;
	static public function fs_link_with_cb(loop:Loop, req:FsRequest, path:Bytes, new_path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_symlink_with_cb(loop:Loop, req:FsRequest, path:Bytes, new_path:Bytes, flags:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_readlink_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_realpath_with_cb(loop:Loop, req:FsRequest, path:Bytes, use_uv_fs_cb:Bool):Int;
	static public function fs_chown_with_cb(loop:Loop, req:FsRequest, path:Bytes, uid:Int, gid:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_fchown_with_cb(loop:Loop, req:FsRequest, file:File, uid:Int, gid:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_lchown_with_cb(loop:Loop, req:FsRequest, path:Bytes, uid:Int, gid:Int, use_uv_fs_cb:Bool):Int;
	static public function fs_get_type(req:FsRequest):FsRequestType;
	static public function fs_get_result(req:FsRequest):I64;
	static public function fs_get_system_error(req:FsRequest):Int;
	static public function fs_get_ptr(req:FsRequest):Pointer;
	static public function fs_get_path(req:FsRequest):Bytes;
	static public function fs_get_statbuf(req:FsRequest):RawStat;
	static public function fs_event_init(loop:Loop, handle:FsEvent):Int;
	static public function fs_event_start_with_cb(handle:FsEvent, path:Bytes, flags:UInt):Int;
	static public function fs_event_stop(handle:FsEvent):Int;
	static public function fs_event_getpath(handle:FsEvent, buffer:Bytes, size:Ref<U64>):Int;
	static public function fs_poll_init(loop:Loop, handle:FsPoll):Int;
	static public function fs_poll_start_with_cb(handle:FsPoll, path:Bytes, interval:UInt):Int;
	static public function fs_poll_stop(handle:FsPoll):Int;
	static public function fs_poll_getpath(handle:FsPoll, buffer:Bytes, size:Ref<U64>):Int;
	static public function is_active(handle:Handle):Int;
	static public function is_closing(handle:Handle):Int;
	static public function close_with_cb(handle:Handle):Void;
	static public function ref(handle:Handle):Void;
	static public function unref(handle:Handle):Void;
	static public function has_ref(handle:Handle):Int;
	static public function handle_size(type:HandleType):U64;
	static public function send_buffer_size(handle:Handle, value:Ref<Int>):Int;
	static public function recv_buffer_size(handle:Handle, value:Ref<Int>):Int;
	static public function handle_get_loop(handle:Handle):Loop;
	static public function handle_get_data(handle:Handle):Pointer;
	static public function handle_set_data(handle:Handle, data:Pointer):Pointer;
	static public function handle_get_type(handle:Handle):HandleType;
	static public function handle_type_name(type:HandleType):Bytes;
	static public function idle_init(loop:Loop, idle:Idle):Int;
	static public function idle_start_with_cb(idle:Idle):Int;
	static public function idle_stop(idle:Idle):Int;
	static public function loop_init(loop:Loop):Int;
	static public function loop_close(loop:Loop):Int;
	static public function default_loop():Loop;
	static public function run(loop:Loop, mode:LoopRunMode):Int;
	static public function loop_alive(loop:Loop):Int;
	static public function stop(loop:Loop):Void;
	static public function loop_size():U64;
	static public function backend_fd(loop:Loop):Int;
	static public function backend_timeout(loop:Loop):Int;
	static public function now(loop:Loop):U64;
	static public function update_time(loop:Loop):Void;
	static public function walk_with_cb(loop:Loop, arg:Pointer):Void;
	static public function loop_fork(loop:Loop):Int;
	static public function loop_get_data(loop:Loop):Pointer;
	static public function loop_set_data(loop:Loop, data:Pointer):Pointer;
	static public function metrics_idle_time(loop:Loop):U64;
	static public function guess_handle(file:File):HandleType;
	static public function library_shutdown():Void;
	static public function buf_init(base:Bytes, len:UInt):Buffer;
	static public function setup_args(argc:Int, argv:Ref<Bytes>):Ref<Bytes>;
	static public function get_process_title(buffer:Bytes, size:U64):Int;
	static public function set_process_title(title:Bytes):Int;
	static public function resident_set_memory(rss:Ref<U64>):Int;
	static public function uptime(uptime:Ref<Float>):Int;
	static public function getrusage(rusage:RawRUsage):Int;
	static public function os_getpid():Int;
	static public function os_getppid():Int;
	static public function cpu_info(cpu_infos:Ref<RawCpuInfo>, count:Ref<Int>):Int;
	static public function free_cpu_info(cpu_infos:RawCpuInfo, count:Int):Void;
	static public function interface_addresses(addresses:Ref<RawInterfaceAddress>, count:Ref<Int>):Int;
	static public function free_interface_addresses(addresses:RawInterfaceAddress, count:Int):Void;
	static public function loadavg(avg:Ref<Float>):Void;
	static public function ip4_addr(ip:Bytes, port:Int, addr:RawSockAddrIn):Int;
	static public function ip6_addr(ip:Bytes, port:Int, addr:RawSockAddrIn6):Int;
	static public function ip4_name(src:RawSockAddrIn, dst:Bytes, size:U64):Int;
	static public function ip6_name(src:RawSockAddrIn6, dst:Bytes, size:U64):Int;
	static public function inet_ntop(af:Int, src:Pointer, dst:Bytes, size:U64):Int;
	static public function inet_pton(af:Int, src:Bytes, dst:Pointer):Int;
	static public function if_indextoname(ifindex:UInt, buffer:Bytes, size:Ref<U64>):Int;
	static public function if_indextoiid(ifindex:UInt, buffer:Bytes, size:Ref<U64>):Int;
	static public function exepath(buffer:Bytes, size:Ref<U64>):Int;
	static public function cwd(buffer:Bytes, size:Ref<U64>):Int;
	static public function chdir(dir:Bytes):Int;
	static public function os_homedir(buffer:Bytes, size:Ref<U64>):Int;
	static public function os_tmpdir(buffer:Bytes, size:Ref<U64>):Int;
	static public function os_get_passwd(pwd:RawPasswd):Int;
	static public function os_free_passwd(pwd:RawPasswd):Void;
	static public function get_free_memory():U64;
	static public function get_total_memory():U64;
	static public function get_constrained_memory():U64;
	static public function hrtime():U64;
	static public function os_getenv(name:Bytes, buffer:Bytes, size:Ref<U64>):Int;
	static public function os_setenv(name:Bytes, value:Bytes):Int;
	static public function os_unsetenv(name:Bytes):Int;
	static public function os_gethostname(buffer:Bytes, size:Ref<U64>):Int;
	static public function os_getpriority(pid:Int, priority:Ref<Int>):Int;
	static public function os_setpriority(pid:Int, priority:Int):Int;
	static public function os_uname(buffer:RawUtsName):Int;
	static public function gettimeofday(tv:RawTimeVal64):Int;
	static public function random_with_cb(loop:Loop, req:RandomRequest, buf:Pointer, buflen:U64, flags:UInt):Int;
	static public function sleep(msec:UInt):Void;
	static public function pipe_init(loop:Loop, handle:Pipe, ipc:Int):Int;
	static public function pipe_open(handle:Pipe, file:File):Int;
	static public function pipe_bind(handle:Pipe, name:Bytes):Int;
	static public function pipe_connect_with_cb(req:ConnectRequest, handle:Pipe, name:Bytes):Void;
	static public function pipe_getsockname(handle:Pipe, buffer:Bytes, size:Ref<U64>):Int;
	static public function pipe_getpeername(handle:Pipe, buffer:Bytes, size:Ref<U64>):Int;
	static public function pipe_pending_instances(handle:Pipe, count:Int):Void;
	static public function pipe_pending_count(handle:Pipe):Int;
	static public function pipe_pending_type(handle:Pipe):HandleType;
	static public function pipe_chmod(handle:Pipe, flags:Int):Int;
	static public function pipe(fds:Ref<File>, read_flags:Int, write_flags:Int):Int;
	static public function prepare_init(loop:Loop, prepare:Prepare):Int;
	static public function prepare_start_with_cb(prepare:Prepare):Int;
	static public function prepare_stop(prepare:Prepare):Int;
	static public function disable_stdio_inheritance():Void;
	static public function spawn(loop:Loop, handle:Process, options:RawProcessOptions):Int;
	static public function process_kill(handle:Process, signum:Int):Int;
	static public function kill(pid:Int, signum:Int):Int;
	static public function process_get_pid(handle:Process):Int;
	static public function cancel(req:Request):Int;
	static public function req_size(type:RequestType):U64;
	static public function req_get_data(req:Request):Pointer;
	static public function req_set_data(req:Request, data:Pointer):Pointer;
	static public function req_get_type(req:Request):RequestType;
	static public function req_type_name(type:RequestType):Bytes;
	static public function signal_init(loop:Loop, signal:Signal):Int;
	static public function signal_start_with_cb(signal:Signal, signum:Int):Int;
	static public function signal_start_oneshot_with_cb(signal:Signal, signum:Int):Int;
	static public function signal_stop(signal:Signal):Int;
	static public function shutdown_with_cb(req:ShutdownRequest, handle:Stream):Int;
	static public function listen_with_cb(stream:Stream, backlog:Int):Int;
	static public function accept(server:Stream, client:Stream):Int;
	static public function read_start_with_cb(stream:Stream):Int;
	static public function read_stop(stream:Stream):Int;
	static public function write_with_cb(req:WriteRequest, handle:Stream, bufs:Ref<Buffer>, nbufs:UInt):Int;
	static public function write2_with_cb(req:WriteRequest, handle:Stream, bufs:Ref<Buffer>, nbufs:UInt, send_handle:Stream):Int;
	static public function try_write(handle:Stream, bufs:Ref<Buffer>, nbufs:UInt):Int;
	static public function try_write2(handle:Stream, bufs:Ref<Buffer>, nbufs:UInt, send_handle:Stream):Int;
	static public function is_readable(handle:Stream):Int;
	static public function is_writable(handle:Stream):Int;
	static public function stream_set_blocking(handle:Stream, blocking:Int):Int;
	static public function stream_get_write_queue_size(stream:Stream):U64;
	static public function tcp_init(loop:Loop, handle:Tcp):Int;
	static public function tcp_init_ex(loop:Loop, handle:Tcp, flags:UInt):Int;
	static public function tcp_nodelay(handle:Tcp, enable:Int):Int;
	static public function tcp_keepalive(handle:Tcp, enable:Int, delay:UInt):Int;
	static public function tcp_simultaneous_accepts(handle:Tcp, enable:Int):Int;
	static public function tcp_bind(handle:Tcp, addr:SockAddr, flags:UInt):Int;
	static public function tcp_getsockname(handle:Tcp, name:SockAddr, namelen:Ref<Int>):Int;
	static public function tcp_getpeername(handle:Tcp, name:SockAddr, namelen:Ref<Int>):Int;
	static public function tcp_connect_with_cb(req:ConnectRequest, handle:Tcp, addr:SockAddr):Int;
	static public function tcp_close_reset_with_cb(handle:Tcp):Int;
	static public function timer_init(loop:Loop, handle:Timer):Int;
	static public function timer_start_with_cb(handle:Timer, timeout:U64, repeat:U64):Int;
	static public function timer_stop(handle:Timer):Int;
	static public function timer_again(handle:Timer):Int;
	static public function timer_set_repeat(handle:Timer, repeat:U64):Void;
	static public function timer_get_repeat(handle:Timer):U64;
	static public function timer_get_due_in(handle:Timer):U64;
	static public function tty_init(loop:Loop, handle:Tty, fd:File, unused:Int):Int;
	static public function tty_set_mode(handle:Tty, mode:TtyMode):Int;
	static public function tty_reset_mode():Int;
	static public function tty_get_winsize(handle:Tty, width:Ref<Int>, height:Ref<Int>):Int;
	static public function tty_set_vterm_state(state:TtyVTermState):Void;
	static public function tty_get_vterm_state(state:Ref<TtyVTermState>):Int;
	static public function udp_init(loop:Loop, handle:Udp):Int;
	static public function udp_init_ex(loop:Loop, handle:Udp, flags:UInt):Int;
	static public function udp_bind(handle:Udp, addr:SockAddr, flags:UInt):Int;
	static public function udp_connect(handle:Udp, addr:SockAddr):Int;
	static public function udp_getpeername(handle:Udp, name:SockAddr, namelen:Ref<Int>):Int;
	static public function udp_getsockname(handle:Udp, name:SockAddr, namelen:Ref<Int>):Int;
	static public function udp_set_membership(handle:Udp, multicast_addr:Bytes, interface_addr:Bytes, membership:UdpMembership):Int;
	static public function udp_set_source_membership(handle:Udp, multicast_addr:Bytes, interface_addr:Bytes, source_addr:Bytes, membership:UdpMembership):Int;
	static public function udp_set_multicast_loop(handle:Udp, on:Int):Int;
	static public function udp_set_multicast_ttl(handle:Udp, ttl:Int):Int;
	static public function udp_set_multicast_interface(handle:Udp, interface_addr:Bytes):Int;
	static public function udp_set_broadcast(handle:Udp, on:Int):Int;
	static public function udp_set_ttl(handle:Udp, ttl:Int):Int;
	static public function udp_send_with_cb(req:UdpSendRequest, handle:Udp, bufs:Ref<Buffer>, nbufs:UInt, addr:SockAddr):Int;
	static public function udp_try_send(handle:Udp, bufs:Ref<Buffer>, nbufs:UInt, addr:SockAddr):Int;
	static public function udp_recv_start_with_cb(handle:Udp):Int;
	static public function udp_using_recvmmsg(handle:Udp):Int;
	static public function udp_recv_stop(handle:Udp):Int;
	static public function udp_get_send_queue_size(handle:Udp):U64;
	static public function udp_get_send_queue_count(handle:Udp):U64;
	static public function version():UInt;
	static public function version_string():Bytes;
}
